'''You must solve the problem without using any built-in functions in O(nlog(n)) time complexity 
and with the smallest space complexity possible.'''




class Solution:
    def sortArray(self, nums: List[int]) -> List[int]:
        '''Heap Sort Θ(nlogn) O(1)
There are two parts in this sort. One part is a utility to get any index on the top, 
the other part is to make the heap as a max one without sorting, and then swap the largest down and cut it off. 
At the end, the heap and array length should be zero.'''

        if len(nums) > 1:
            # arr分两半
            mid = len(nums) // 2
            left = nums[:mid]
            right = nums[mid:]

            # 越分越细，递归
            self.sortArray(left)
            self.sortArray(right)

            l = r = p = 0 #l=左指针，r=右指针，p=pivot

            # 左右两边队首，谁小谁就先进总nums
            while l < len(left) and r < len(right):
                if left[l] < right[r]:
                    nums[p] = left[l]
                    l += 1
                else:
                    nums[p] = right[r]
                    r += 1
                p += 1

           #两边有剩下的怎么办？排队进
            while l < len(left):
                nums[p] = left[l]
                l += 1
                p += 1
            while r < len(right):
                nums[p] = right[r]
                r += 1
                p += 1

        return nums

