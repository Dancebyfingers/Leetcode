'''Given two strings s and t of lengths m and n respectively, return the minimum window 
substring of s such that every character in t (including duplicates) is included in the window.
If there is no such substring, return the empty string "".
The testcases will be generated such that the answer is unique.

Example 1:
Input: s = "ADOBECODEBANC", t = "ABC"
Output: "BANC"
Explanation: The minimum window substring "BANC" includes 'A', 'B', and 'C' from string t.

Example 2:
Input: s = "a", t = "a"
Output: "a"
Explanation: The entire string s is the minimum window.

Example 3:
Input: s = "a", t = "aa"
Output: ""
Explanation: Both 'a's from t must be included in the window.
Since the largest window of s only has one 'a', return empty string.

Constraints:
m == s.length
n == t.length
1 <= m, n <= 105
s and t consist of uppercase and lowercase English letters.
 
Follow up: Could you find an algorithm that runs in O(m + n) time?'''

'''这道题也可以不用 HashMap，直接用个 int 的数组来代替，因为 ASCII 只有256个字符，所以用个大小为 256 的 int 数组即可代替 HashMap，
但由于一般输入字母串的字符只有 128 个，所以也可以只用 128，其余部分的思路完全相同，虽然只改了一个数据结构，但是运行速度提高了一倍，
说明数组还是比 HashMap 快啊。在热心网友 chAngelts 的提醒下，还可以进一步的优化，没有必要每次都计算子串，只要有了起始位置和长度，
就能唯一的确定一个子串。这里使用一个全局变量 minLeft 来记录最终结果子串的起始位置，初始化为 -1，最终配合上 minLen，就可以得到最终结果了。
注意在返回的时候要检测一下若 minLeft 仍为初始值 -1，需返回空串'''

class Solution:
    def minWindow(self, s, t):
        t_ch = [0] * 128
        left = 0
        cnt = 0
        minLeft = -1
        minLen = float("inf")
        
        for ch in t:
            t_ch[ord(ch)] += 1
        
        for i, sch in enumerate(s):
            t_ch[ord(sch)] -= 1
            if t_ch[ord(sch)] >= 0:
                cnt += 1
            
            while cnt == len(t):
                if minLen > i - left + 1:
                    minLen = i - left + 1
                    minLeft = left
                
                t_ch[ord(s[left])] += 1
                if t_ch[ord(s[left])] > 0:
                    cnt -= 1
                left += 1
        
        return "" if minLeft == -1 else s[minLeft:minLeft + minLen]

